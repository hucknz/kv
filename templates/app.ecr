<!DOCTYPE html>
<html data-theme="dark">
<head>
    <title>KVM Stream</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="manifest" href="/assets/manifest.json">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
      html, body {
        font-family: 'Oxanium', Arial, sans-serif;
      }
      h1, h2, h3, h4, h5, h6, header h1 {
        font-family: 'Oxanium', Arial, sans-serif !important;
        letter-spacing: 0.01em;
      }
      .material-icons {
        font-family: 'Material Icons', sans-serif;
        font-size: 1em !important;
        vertical-align: middle;
        margin-right: 0.2em;
        line-height: 1;
        height: 1em;
        width: 1em;
        display: inline-block;
      }
      .video-status-bar .material-icons {
        font-size: 1.1em !important;
      }
    </style>
    <style>
        :root {
            --sidebar-width: 320px;
        }
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: var(--sidebar-width);
            height: 100vh;
            background: rgba(18, 18, 20, 0.8); /* Dark translucent background */
            backdrop-filter: blur(12px); /* Add blur effect for modern look */
            -webkit-backdrop-filter: blur(12px); /* Safari support */
            border-left: 1px solid rgba(64, 64, 64, 0.6); /* Semi-transparent border */
            transform: translateX(0);
            transition: transform 0.3s ease;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            box-shadow: -8px 0 32px rgba(0, 0, 0, 0.4); /* Add shadow for depth */
        }
        .sidebar.collapsed {
            transform: translateX(var(--sidebar-width));
        }
        .sidebar-content {
            padding: 1rem;
            overflow-y: auto;
            flex-grow: 1;
        }
        .sidebar-toggle {
            position: absolute;
            top: 1rem; /* Move to top */
            left: -3rem; /* Move further left for better visibility */
            transform: none; /* Remove center transform */
            width: 3rem; /* Make wider for better visibility */
            height: 3rem; /* Square shape */
            background: var(--pico-color-indigo-600);
            border: 2px solid var(--pico-color-indigo-400); /* Thicker border */
            border-right: none;
            border-radius: var(--pico-border-radius) 0 0 var(--pico-border-radius);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--pico-color-white);
            z-index: 1000;
            font-size: 1.8rem; /* Larger icon */
            font-weight: bold; /* Make icon bolder */
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            box-shadow: -4px 0 8px rgba(0,0,0,0.2); /* Stronger shadow */
            transition: all 0.2s ease; /* Smooth hover effect */
        }
        .sidebar-toggle:hover {
            background: var(--pico-color-indigo-500);
            transform: translateX(-2px); /* Slide out slightly on hover */
            box-shadow: -6px 0 12px rgba(0,0,0,0.3);
        }
        #main-container {
            flex-grow: 1;
            width: 100%;
            padding: 0.5rem;
            padding-top: calc(0.5rem + 2.5rem); /* Add top padding for fixed status bar */
            display: flex;
            flex-direction: column;
            min-height: 0; /* Allow flex shrinking */
            /* Remove transition and margin changes - sidebar now overlays */
        }
        header {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.1);
            border-radius: var(--pico-border-radius);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        header h1 {
            margin: 0;
            font-size: 1.5rem;
        }
        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .video-section {
            margin: 0.5rem 0;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-height: 0; /* Allow flex shrinking */
        }
        .video-stream {
            width: 100%;
            max-width: 100%;
            height: 100%;
            max-height: 100%;
            border-radius: var(--pico-border-radius);
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
            cursor: pointer;
            object-fit: contain;
        }
        .video-stream:focus {
            outline: none;
            border-color: var(--pico-color-azure-500);
            box-shadow: 0 0 0 3px var(--pico-color-azure-100);
        }
        .video-container {
            position: relative;
            display: flex;
            justify-content: center;
            width: 100%;
            background: #000;
            border-radius: var(--pico-border-radius);
            flex-grow: 1;
            min-height: 0; /* Allow flex shrinking */
            margin-top: 0; /* Remove top margin since status bar is now fixed */
        }
        .video-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.2s ease;
            z-index: 10;
            transform: translateY(0);
        }
        .video-container:hover .video-controls {
            opacity: 1;
        }
        .video-container.pointer-locked .video-controls {
            display: none !important;
        }
        .video-control-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--pico-border-radius);
            color: white;
            padding: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            width: 36px;
            height: 36px;
        }
        .video-control-btn:hover {
            background: rgba(0, 0, 0, 0.85);
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .video-control-btn:active {
            transform: scale(0.95);
        }
        .video-control-btn.active {
            background: var(--pico-color-azure-500);
            color: white;
        }
        .video-control-btn .material-icons {
            font-size: 20px;
            margin: 0; /* Override default margin */
        }
        .video-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1100; /* Higher than sidebar */
            background: #000;
            border-radius: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .video-container.fullscreen .video-stream {
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: cover;
        }
        .video-container.fullscreen .video-controls {
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(-10px);
        }
        .video-container.fullscreen:hover .video-controls {
            opacity: 1;
            transform: translateY(0);
        }
        .video-container.fullscreen .video-control-btn {
            background: rgba(0, 0, 0, 0.5);
            width: 42px;
            height: 42px;
        }
        .video-container.fullscreen .video-control-btn .material-icons {
            font-size: 24px;
        }
        .video-status-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 1rem;
            padding: 0.25rem 0.75rem;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.9rem;
            z-index: 999; /* Below sidebar but above content */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .video-status-bar > span {
            white-space: nowrap;
        }
        .video-status-bar .good { color: #4ade80; }
        .video-status-bar .warning { color: #fbbf24; }
        .video-status-bar .bad { color: #f87171; }
        .video-status-bar .active-input {
            color: var(--pico-color-azure-400);
            font-weight: bold;
        }
        .no-video {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--pico-muted-color);
            background: #111;
            border-radius: var(--pico-border-radius);
        }
        .video-hint {
            text-align: center;
            margin: 0.5rem 0;
            font-size: 0.875rem;
        }
        .material-icons {
            font-family: 'Material Icons', sans-serif;
            font-size: 1.1em;
            vertical-align: middle;
            margin-right: 0.2em;
        }
        .key-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 0.5rem;
        }
        .key-grid button {
            padding: 0.5rem;
            margin: 0;
            font-size: 0.875rem;
        }
        .combo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 0.5rem;
        }
        .combo-grid button {
            padding: 0.5rem;
            margin: 0;
            font-size: 0.75rem;
        }
        .compact-section { margin-bottom: 1.5rem; }
        .compact-section h3 {
            margin-bottom: 0.75rem;
            font-size: 1rem;
            border-bottom: 1px solid var(--pico-muted-border-color);
            padding-bottom: 0.25rem;
        }
        footer {
            margin-top: auto; /* Push footer to bottom */
            padding: 0.5rem;
            font-size: 0.75rem;
            text-align: center;
            background: rgba(0, 0, 0, 0.1);
            border-radius: var(--pico-border-radius);
            flex-shrink: 0; /* Prevent footer from shrinking */
        }
        @media (max-width: 768px) {
            :root { --sidebar-width: 280px; }
            header {
                flex-direction: column;
                gap: 0.5rem;
                text-align: center;
            }
            .header-controls { justify-content: center; }
            .video-stream { max-height: 70vh; }
        }
    </style>
</head>
<body>
    <aside id="sidebar" class="sidebar collapsed">
        <button id="sidebar-toggle" class="sidebar-toggle" title="Toggle Controls">‹</button>
        <div class="sidebar-content">
            <h2><span class="material-icons">tune</span> Controls</h2>
            <!-- Text Input -->
            <div class="compact-section">
                <h3><span class="material-icons">text_fields</span> Text Input</h3>
                <form id="text-input-form" style="display: flex; gap: 0.5rem;" onsubmit="event.preventDefault(); sendText();">
                    <input type="text" id="text-input" placeholder="Type text to send..." maxlength="200">
                    <button type="submit" style="width: auto;">Send</button>
                </form>
                <div style="margin-top: 0.5rem;">
                    <button onclick="pasteFromClipboard()" class="outline" style="width: 100%;"><span class="material-icons">content_paste</span> Paste Clipboard</button>
                </div>
            </div>

            <!-- Quick Actions -->
            <div class="compact-section">
                <h3><span class="material-icons">keyboard_alt</span> Quick Keys</h3>
                <div class="key-grid">
                    <button onclick="sendKey('enter')" class="outline">Enter</button>
                    <button onclick="sendKey('tab')" class="outline">Tab</button>
                    <button onclick="sendKey('escape')" class="outline">Esc</button>
                    <button onclick="sendKey('backspace')" class="outline">⌫</button>
                    <button onclick="sendKey('delete')" class="outline">Del</button>
                    <button onclick="sendKey('space')" class="outline">Space</button>
                </div>
            </div>

            <!-- Key Combinations -->
            <div class="compact-section">
                <h3><span class="material-icons">shortcut</span> Shortcuts</h3>
                <div class="combo-grid">
                    <button onclick="sendCombination(['ctrl'], ['c'])" class="outline">Ctrl+C</button>
                    <button onclick="sendCombination(['ctrl'], ['v'])" class="outline">Ctrl+V</button>
                    <button onclick="sendCombination(['ctrl'], ['x'])" class="outline">Ctrl+X</button>
                    <button onclick="sendCombination(['ctrl'], ['z'])" class="outline">Ctrl+Z</button>
                    <button onclick="sendCombination(['ctrl'], ['a'])" class="outline">Ctrl+A</button>
                    <button onclick="sendCombination(['alt'], ['tab'])" class="outline">Alt+Tab</button>
                    <button onclick="pasteFromClipboard()" class="outline" title="Paste from your clipboard"><span class="material-icons" style="font-size: 0.8em;">content_paste</span> Paste</button>
                </div>
            </div>

            <!-- Mouse Controls -->
            <div class="compact-section">
                <h3><span class="material-icons">mouse</span> Mouse Buttons</h3>
                <div class="key-grid">
                    <button onclick="sendMouseClick('left')" class="outline">L Click</button>
                    <button onclick="sendMouseClick('right')" class="outline">R Click</button>
                    <button onclick="sendMouseClick('middle')" class="outline">M Click</button>
                </div>
            </div>

            <!-- Video Controls Section (New) -->
            <div class="compact-section">
                <h3><span class="material-icons">videocam</span> Video Controls</h3>
                <div style="font-size: 0.85rem; margin-bottom: 0.5rem;">
                    <p><span class="material-icons" style="font-size: 0.9em;">fullscreen</span> <strong>Fullscreen:</strong> F11 or Ctrl+F</p>
                    <p><span class="material-icons" style="font-size: 0.9em;">photo_camera</span> <strong>Screenshot:</strong> Ctrl+S or Alt+S</p>
                    <p><span class="material-icons" style="font-size: 0.9em;">mouse</span> <strong>Input Capture:</strong> Click on video</p>
                    <p><span class="material-icons" style="font-size: 0.9em;">logout</span> <strong>Release Input:</strong> ESC key</p>
                </div>
            </div>

            <!-- USB Mass Storage (Disk Image Selection) -->
            <div class="compact-section">
                <h3><span class="material-icons">usb</span> Virtual USB Drive</h3>
                <div id="usb-image-list" style="max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.1); padding: 0.5rem; border-radius: var(--pico-border-radius); font-family: monospace; font-size: 0.9rem;">
                    Loading disk images...
                </div>
                <div style="margin-top: 0.5rem;">
                    <button id="detach-usb-btn" class="outline" style="display:none;"><span class="material-icons">eject</span> Detach</button>
                </div>
            </div>

            <!-- ECM/Ethernet Controls -->
            <div class="compact-section">
                <h3><span class="material-icons">cable</span> Network (ECM)</h3>
                <div id="ethernet-status-indicator" style="margin-bottom:0.5rem; font-size:0.95em;">
                    <span class="material-icons" id="ethernet-status-icon">cable</span>
                    <span id="ethernet-status-label">Checking...</span>
                </div>
                <div style="display:flex; gap:0.5rem;">
                    <button id="ethernet-enable-btn" class="outline" onclick="setEthernet(true)"><span class="material-icons">lan</span>Enable</button>
                    <button id="ethernet-disable-btn" class="outline" onclick="setEthernet(false)"><span class="material-icons">lan_off</span>Disable</button>
                </div>
                <div id="ethernet-ifname" style="margin-top:0.3rem; font-size:0.85em; color:#aaa;"></div>
            </div>
        </div>
    </aside>

    <main id="main-container" class="container">
        <!-- Header -->
        <header>
            <h1><span class="material-icons">desktop_windows</span> Remote KVM</h1>
            <div class="header-controls">
                <!-- Restart button removed -->
            </div>
        </header>

        <!-- Video Stream -->
        <section class="video-section">
            <div class="video-status-bar" id="video-status-bar">
                <span id="latency-indicator"><span class="material-icons">speed</span>--ms</span>
                <span id="fps-indicator"><span class="material-icons">timer</span>FPS:--</span>
                <span id="video-status"><span class="material-icons">monitor</span>Video:--</span>
                <span id="keyboard-status"><span class="material-icons">keyboard</span></span>
                <span id="mouse-status"><span class="material-icons">mouse</span></span>
                <span id="storage-status"><span class="material-icons">usb</span></span>
                <span id="ethernet-status-bar"><span class="material-icons">cable</span></span>
                <span id="input-status"></span>
                <span id="controls-hint" style="display:none;" class="good"><span class="material-icons">tips_and_updates</span>Tip: Hover over video for controls</span>
            </div>
            <div class="video-container">
                <img id="video-stream" class="video-stream" 
                     alt="KVM Video Stream"
                     tabindex="0"
                     title="Click to capture mouse and keyboard input"
                     onload="this.style.display='block'; document.getElementById('no-video').style.display='none';"
                     onerror="this.style.display='none'; document.getElementById('no-video').style.display='block';"
                     crossorigin="anonymous">
                <div class="video-controls">
                    <button id="audio-btn" class="video-control-btn" onclick="toggleAudio()" title="Toggle Audio">
                        <span class="material-icons">volume_up</span>
                    </button>
                    <button id="fullscreen-btn" class="video-control-btn" onclick="toggleFullscreen()" title="Toggle Fullscreen">
                        <span class="material-icons">fullscreen</span>
                    </button>
                    <button id="screenshot-btn" class="video-control-btn" onclick="takeScreenshot()" title="Take Screenshot">
                        <span class="material-icons">photo_camera</span>
                    </button>
                </div>
            </div>
            <div id="no-video" class="no-video">
                <span class="material-icons">videocam_off</span> Video starting up...
            </div>
        </section>

        <!-- Info -->
        <footer>
            <small>
                <strong>KV:</strong> A remote KVM | <a href="https://github.com/ralsina/kv" target="_blank" rel="noopener noreferrer" style="color: var(--pico-color-azure-400); text-decoration: none;">Source Code</a>
            </small>
        </footer>
    </main>

    <script>
        // ECM/Ethernet enable/disable controls
        function setEthernet(enable) {
            fetch('/api/ethernet/' + (enable ? 'enable' : 'disable'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                // Optionally show a notification or update status immediately
                updateStatus();
            })
            .catch(error => {
                console.error('Failed to set ethernet:', error);
            });
        }
        let audioStream = null;
        let audioLatencyInterval = null;

        function manageAudioLatency(audioElement) {
            if (audioLatencyInterval) clearInterval(audioLatencyInterval);

            audioLatencyInterval = setInterval(() => {
                if (audioElement.buffered.length > 0) {
                    const bufferEnd = audioElement.buffered.end(audioElement.buffered.length - 1);
                    const currentTime = audioElement.currentTime;
                    const latency = bufferEnd - currentTime;

                    // If latency is over a threshold (e.g., 1 second), seek to the live edge
                    if (latency > 1.0) {
                        console.log(`High audio latency detected (${latency.toFixed(2)}s), seeking to live edge.`);
                        audioElement.currentTime = bufferEnd;
                    }
                }
            }, 30000); // Check every 30 seconds
        }

        function toggleAudio() {
            const audioBtn = document.getElementById('audio-btn');
            const icon = audioBtn.querySelector('.material-icons');

            if (audioStream) {
                // Stop the stream
                if (audioLatencyInterval) clearInterval(audioLatencyInterval);
                audioStream.pause();
                audioStream.src = '';
                audioStream.load();
                try {
                    document.body.removeChild(audioStream);
                } catch (e) {}
                audioStream = null;
                icon.textContent = 'volume_up';
                audioBtn.title = 'Start Audio';
                audioBtn.classList.remove('active');
            } else {
                // Start the stream
                audioStream = document.createElement('audio');
                audioStream.src = '/audio.ogg';
                audioStream.autoplay = false; // We control play explicitly
                audioStream.style.display = 'none'; // Hide the element

                audioStream.addEventListener('play', () => {
                    icon.textContent = 'volume_off';
                    audioBtn.title = 'Stop Audio';
                    audioBtn.classList.add('active');
                    manageAudioLatency(audioStream);
                });

                audioStream.addEventListener('error', (e) => {
                    console.error("Audio playback error:", e);
                    // Reset on error
                    if (audioLatencyInterval) clearInterval(audioLatencyInterval);
                    if (audioStream) {
                        audioStream.pause();
                        audioStream.src = '';
                        audioStream.load();
                        try {
                            document.body.removeChild(audioStream);
                        } catch (err) {}
                        audioStream = null;
                    }
                    icon.textContent = 'volume_up';
                    audioBtn.title = 'Start Audio';
                    audioBtn.classList.remove('active');
                });

                document.body.appendChild(audioStream);
                audioStream.play().catch(e => console.error("Audio play failed:", e));
            }
        }

        // FPS Indicator: Use server-reported FPS from /api/status
        function updateFpsIndicator(fps) {
            const fpsIndicator = document.getElementById('fps-indicator');
            if (fpsIndicator) {
                const fpsVal = (typeof fps === 'number' && !isNaN(fps)) ? fps.toFixed(1) : '--';
                fpsIndicator.innerHTML = `<span class="material-icons">timer</span>FPS:${fpsVal}`;
                fpsIndicator.className = '';
                if (fps >= 30) fpsIndicator.classList.add('good');
                else if (fps >= 15) fpsIndicator.classList.add('warning');
                else fpsIndicator.classList.add('bad');
            }
        }
        let videoFocused = false;
        let pointerLocked = false;
        let pressedButtons = new Set(); // Track currently pressed mouse buttons
        
        // restartStream removed

        function initializeVideo() {
            const video = document.getElementById('video-stream');
            // Always set src, even if already set, to force reload
            video.src = '/video.mjpg?' + Date.now();
            video.style.display = 'block'; // Ensure it's visible
        }

        function updateStatus() {
            // ECM/Ethernet sidebar indicator and controls (eth must be defined only once after data is fetched)
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    // ECM/Ethernet sidebar indicator and controls
                    const eth = data.ecm || data.ethernet;
                    const ethStatus = document.getElementById('ethernet-status-label');
                    const ethIcon = document.getElementById('ethernet-status-icon');
                    const enableBtn = document.getElementById('ethernet-enable-btn');
                    const disableBtn = document.getElementById('ethernet-disable-btn');
                    const ethIfname = document.getElementById('ethernet-ifname');
                    if (ethStatus && ethIcon && enableBtn && disableBtn) {
                        if (eth) {
                            if (eth.enabled) {
                                ethStatus.textContent = 'Enabled';
                                ethIcon.textContent = 'lan';
                                ethIcon.className = 'material-icons good';
                                enableBtn.disabled = true;
                                disableBtn.disabled = false;
                            } else {
                                ethStatus.textContent = 'Disabled';
                                ethIcon.textContent = 'lan_off';
                                ethIcon.className = 'material-icons bad';
                                enableBtn.disabled = false;
                                disableBtn.disabled = true;
                            }
                            if (eth.ifname) {
                                ethIfname.textContent = 'Interface: ' + eth.ifname + (eth.ip ? ' (' + eth.ip + ')' : '');
                            } else {
                                ethIfname.textContent = '';
                            }
                        } else {
                            ethStatus.textContent = 'Unavailable';
                            ethIcon.textContent = 'cable';
                            ethIcon.className = 'material-icons';
                            enableBtn.disabled = false;
                            disableBtn.disabled = false;
                            ethIfname.textContent = '';
                        }
                    }
                    const videoStatus = document.getElementById('video-status');
                    const keyboardStatus = document.getElementById('keyboard-status');
                    const mouseStatus = document.getElementById('mouse-status');
                    const storageStatus = document.getElementById('storage-status');

                    if (data.video.status === 'running') {
                        videoStatus.innerHTML = '<span class="material-icons">videocam</span>Live (' + data.video.resolution + '@' + data.video.fps + 'fps)';
                        videoStatus.classList.add('good');
                    } else {
                        videoStatus.innerHTML = '<span class="material-icons">videocam_off</span>Connecting...';
                        videoStatus.classList.remove('good');
                    }

                    // Update FPS indicator with server-reported FPS
                    updateFpsIndicator(data.video.actual_fps);

                    // ECM/Ethernet status bar (icon-only, color for status)
                    const ethBar = document.getElementById('ethernet-status-bar');
                    if (ethBar) {
                        if (eth) {
                            if (eth.enabled) {
                                ethBar.innerHTML = '<span class="material-icons good">lan</span>';
                                ethBar.className = 'good';
                            } else {
                                ethBar.innerHTML = '<span class="material-icons bad">lan_off</span>';
                                ethBar.className = 'bad';
                            }
                        } else {
                            ethBar.innerHTML = '<span class="material-icons">cable</span>';
                            ethBar.className = '';
                        }
                    }

                    // Keyboard status (icon only)
                    if (data.keyboard.enabled) {
                        keyboardStatus.innerHTML = '<span class="material-icons good">keyboard</span>';
                        keyboardStatus.className = 'good';
                    } else {
                        keyboardStatus.innerHTML = '<span class="material-icons bad">keyboard</span>';
                        keyboardStatus.className = 'bad';
                    }

                    // Mouse status (icon only)
                    if (data.mouse.enabled) {
                        mouseStatus.innerHTML = '<span class="material-icons good">mouse</span>';
                        mouseStatus.className = 'good';
                    } else {
                        mouseStatus.innerHTML = '<span class="material-icons bad">mouse</span>';
                        mouseStatus.className = 'bad';
                    }

                    // USB status (icon only)
                    if (data.storage && data.storage.enabled) {
                        storageStatus.innerHTML = '<span class="material-icons good">usb</span>';
                        storageStatus.className = 'good';
                    } else {
                        storageStatus.innerHTML = '<span class="material-icons bad">usb</span>';
                        storageStatus.className = 'bad';
                    }

                    // ...existing code...
                })
                .catch(error => {
                    console.error('Error:', error);
                    document.getElementById('video-status').innerHTML = '<span class="material-icons">monitor</span>';
                    document.getElementById('keyboard-status').innerHTML = '<span class="material-icons">keyboard</span>';
                    document.getElementById('mouse-status').innerHTML = '<span class="material-icons">mouse</span>';
                    document.getElementById('storage-status').innerHTML = '<span class="material-icons">usb</span>';

                    const ethStatus = document.getElementById('ethernet-status-label');
                    const ethIcon = document.getElementById('ethernet-status-icon');
                    const enableBtn = document.getElementById('ethernet-enable-btn');
                    const disableBtn = document.getElementById('ethernet-disable-btn');
                    if (ethStatus && ethIcon && enableBtn && disableBtn) {
                        ethStatus.textContent = 'Error';
                        ethIcon.textContent = 'error';
                        ethIcon.className = 'material-icons bad';
                        enableBtn.disabled = false;
                        disableBtn.disabled = false;
                    }
                });
        }

        function measureLatency() {
            const startTime = performance.now();
            fetch('/api/latency-test')
                .then(response => response.json())
                .then(data => {
                    const endTime = performance.now();
                    const latency = Math.round(endTime - startTime);
                    const indicator = document.getElementById('latency-indicator');
                    indicator.innerHTML = `<span class="material-icons">speed</span>${latency}ms`;
                    indicator.className = 'latency-indicator';
                    if (latency < 50) indicator.classList.add('good');
                    else if (latency < 100) indicator.classList.add('warning');
                    else indicator.classList.add('bad');
                })
                .catch(error => {
                    document.getElementById('latency-indicator').textContent = '♾️ --ms';
                    document.getElementById('latency-indicator').className = 'latency-indicator bad';
                });
        }

        // --- WebSocket input client ---
        let wsInput = null;
        let wsInputReady = false;
        let wsInputQueue = [];
        function wsSendInput(obj) {
            if (wsInputReady && wsInput && wsInput.readyState === 1) {
                wsInput.send(JSON.stringify(obj));
            } else {
                wsInputQueue.push(obj);
            }
        }
        function setupInputWebSocket() {
            wsInput = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/input');
            wsInputReady = false;
            wsInput.onopen = function() {
                wsInputReady = true;
                while (wsInputQueue.length > 0) wsSendInput(wsInputQueue.shift());
            };
            wsInput.onclose = function() { wsInputReady = false; setTimeout(setupInputWebSocket, 1000); };
            wsInput.onerror = function() { wsInput.close(); };
            wsInput.onmessage = function(ev) {
                // Optionally handle status/errors
                // let msg = JSON.parse(ev.data);
            };
        }
        setupInputWebSocket();

        // Fallback for non-input endpoints (text, storage, etc)
        function sendApiRequest(endpoint, body) {
            fetch(endpoint, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(body)
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) console.error(`Request to ${endpoint} failed:`, data.message);
            })
            .catch(error => console.error(`Error sending to ${endpoint}:`, error));
        }

        // Input event senders (now use WebSocket)
        function sendKey(key) { wsSendInput({type: 'key_press', key}); }
        function sendCombination(modifiers, keys) { wsSendInput({type: 'key_combination', modifiers, keys}); }
        function sendMouseClick(button) { wsSendInput({type: 'mouse_click', button}); }
        function sendMousePress(button) {
            pressedButtons.add(button);
            wsSendInput({type: 'mouse_press', button});
        }
        function sendMouseRelease(button) {
            pressedButtons.delete(button);
            wsSendInput({type: 'mouse_release', button});
        }
        function sendMouseWheel(delta) { wsSendInput({type: 'mouse_wheel', delta}); }
        function sendSingleMouseMove(x, y) {
            wsSendInput({type: 'mouse_move', x, y, buttons: Array.from(pressedButtons)});
        }

        function sendText() {
            const textInput = document.getElementById('text-input');
            const text = textInput.value.trim();
            if (!text) return;
            sendApiRequest('/api/keyboard/text', {text});
            textInput.value = '';
        }

        async function pasteFromClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                if (text) {
                    sendApiRequest('/api/keyboard/text', {text});
                    console.log('Pasted text:', text.substring(0, 50) + (text.length > 50 ? '...' : ''));
                }
            } catch (err) {
                console.error('Failed to read clipboard:', err);
                // Fallback: show a prompt for manual paste
                const text = prompt('Paste your text here (automatic clipboard access not available):');
                if (text) {
                    sendApiRequest('/api/keyboard/text', {text});
                }
            }
        }

        function keyEventToHIDKey(event) {
            const key = event.key;
            const keyMap = {
                'Enter': 'enter', 'Escape': 'escape', 'Backspace': 'backspace', 'Tab': 'tab',
                'Delete': 'delete', 'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left',
                'ArrowRight': 'right', 'Home': 'home', 'End': 'end', 'PageUp': 'pageup',
                'PageDown': 'pagedown', 'Insert': 'insert', 'CapsLock': 'caps-lock',
                'NumLock': 'num-lock', ' ': 'space'
            };
            if (key.startsWith('F') && key.length > 1 && key.length <= 3) return key.toLowerCase();
            if (keyMap[key]) return keyMap[key];
            if (key.length === 1) return key;
            return null;
        }

        function getModifiers(event) {
            const modifiers = [];
            if (event.ctrlKey) modifiers.push('ctrl');
            if (event.shiftKey) modifiers.push('shift');
            if (event.altKey) modifiers.push('alt');
            if (event.metaKey) modifiers.push('meta');
            return modifiers;
        }

        function setupVideoCapture() {
            const video = document.getElementById('video-stream');
            const videoStatusBar = document.getElementById('video-status-bar');
            const inputStatus = document.getElementById('input-status');

            document.addEventListener('pointerlockchange', () => {
                pointerLocked = (document.pointerLockElement === video);
                videoFocused = pointerLocked;
                videoStatusBar.classList.toggle('input-active', pointerLocked);
                inputStatus.innerHTML = pointerLocked ? `Input Active (ESC to release)` : '';
                // Hide controls when pointer is locked
                const videoContainer = video.closest('.video-container');
                if (videoContainer) {
                    if (pointerLocked) {
                        videoContainer.classList.add('pointer-locked');
                    } else {
                        videoContainer.classList.remove('pointer-locked');
                    }
                }
                if (!pointerLocked) {
                    pressedButtons.forEach(button => sendMouseRelease(button));
                }
            });

            video.addEventListener('focus', () => {
                if (!pointerLocked) {
                    videoFocused = true;
                    videoStatusBar.classList.add('input-active');
                    inputStatus.innerHTML = `Input Active`;
                }
            });
            video.addEventListener('blur', () => {
                if (!pointerLocked) {
                    videoFocused = false;
                    videoStatusBar.classList.remove('input-active');
                    inputStatus.textContent = '';
                }
            });
            video.addEventListener('click', (e) => { e.preventDefault(); video.requestPointerLock(); });
            video.addEventListener('mousemove', (e) => {
                if (pointerLocked) sendSingleMouseMove(e.movementX, e.movementY);
            });
            video.addEventListener('mousedown', (e) => {
                if (!videoFocused) return;
                e.preventDefault();
                const button = e.button === 0 ? 'left' : e.button === 1 ? 'middle' : 'right';
                sendMousePress(button);
            });
            video.addEventListener('mouseup', (e) => {
                if (!videoFocused) return;
                e.preventDefault();
                const button = e.button === 0 ? 'left' : e.button === 1 ? 'middle' : 'right';
                sendMouseRelease(button);
            });
            video.addEventListener('keydown', (e) => {
                if (!videoFocused) return;
                // Always prevent browser shortcuts when video is focused and a key is sent to the server
                const hidKey = keyEventToHIDKey(e);
                if (hidKey) {
                    e.preventDefault();
                    const modifiers = getModifiers(e);
                    sendCombination(modifiers, [hidKey]);
                }
            });
            video.addEventListener('wheel', (e) => {
                if (!videoFocused) return;
                e.preventDefault();
                const delta = e.deltaY > 0 ? -1 : 1;
                sendMouseWheel(delta);
            });
            video.addEventListener('contextmenu', (e) => e.preventDefault());
            video.addEventListener('paste', (e) => {
                if (!videoFocused) return;
                e.preventDefault();
                const text = e.clipboardData.getData('text');
                if (text) sendApiRequest('/api/keyboard/text', {text});
            });
        }

        document.getElementById('text-input').addEventListener('focus', () => document.getElementById('video-stream').blur());

        // Global keyboard shortcuts for pasting, fullscreen and screenshot
        document.addEventListener('keydown', (e) => {
            // Ctrl+Shift+V for paste (when not in video focus)
            if (e.ctrlKey && e.shiftKey && e.key === 'V' && !videoFocused) {
                e.preventDefault();
                pasteFromClipboard();
            }
            
            // F11 or Ctrl+F for fullscreen toggle
            if ((e.key === 'F11' || (e.ctrlKey && e.key === 'f')) && (videoFocused || document.fullscreenElement)) {
                e.preventDefault();
                toggleFullscreen();
            }
            
            // Ctrl+S or Alt+S for screenshot
            if ((e.ctrlKey && e.key === 's') || (e.altKey && e.key === 's')) {
                e.preventDefault();
                takeScreenshot();
            }
        });


        // USB Mass Storage (Disk Image Selection)
        function refreshUsbImages() {
            fetch('/api/storage/images')
                .then(response => response.json())
                .then(data => {
                    const container = document.getElementById('usb-image-list');
                    const detachBtn = document.getElementById('detach-usb-btn');
                    if (data.success && data.images) {
                        if (data.images.length === 0) {
                            container.innerHTML = '<em>No disk images found in ./disk-images</em>';
                            detachBtn.style.display = 'none';
                        } else {
                            container.innerHTML = data.images.map(img => {
                                const selected = (img === data.selected) ? ' (selected)' : '';
                                return `<div style=\"padding:2px 0;cursor:pointer;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;${img===data.selected?'font-weight:bold;color:#4ade80;':''}\" onclick=\"selectUsbImage('${img}')\" title=\"${img}\">${img}${selected}</div>`;
                            }).join('');
                            detachBtn.style.display = data.selected ? '' : 'none';
                        }
                    } else {
                        container.innerHTML = '<em>Error loading disk images</em>';
                        detachBtn.style.display = 'none';
                    }
                })
                .catch(error => {
                    document.getElementById('usb-image-list').innerHTML = '<em>Error loading disk images</em>';
                    document.getElementById('detach-usb-btn').style.display = 'none';
                });
        }

        function selectUsbImage(image) {
            fetch('/api/storage/select', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({image})
            })
            .then(() => { setTimeout(() => { refreshUsbImages(); updateStatus(); }, 300); })
            .catch(() => { refreshUsbImages(); });
        }

        document.addEventListener('DOMContentLoaded', () => {
            // ...existing code...
            refreshUsbImages();
            document.getElementById('detach-usb-btn').onclick = function() {
                fetch('/api/storage/select', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({image: null})
                }).then(() => { setTimeout(() => { refreshUsbImages(); updateStatus(); }, 300); });
            };

            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('/assets/service-worker.js')
                        .then(registration => {
                            console.log('Service Worker registered with scope:', registration.scope);
                        })
                        .catch(error => {
                            console.error('Service Worker registration failed:', error);
                        });
                });
            }
        });

        // Sidebar Toggle with Local Storage
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        
        // Load sidebar state from localStorage
        function loadSidebarState() {
            const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
            if (isCollapsed) {
                sidebar.classList.add('collapsed');
                sidebarToggle.innerHTML = '‹';
            } else {
                sidebar.classList.remove('collapsed');
                sidebarToggle.innerHTML = '›';
            }
            // Remove body class management since sidebar now overlays
        }
        
        // Save sidebar state to localStorage
        function saveSidebarState(isCollapsed) {
            localStorage.setItem('sidebarCollapsed', isCollapsed.toString());
        }
        
        sidebarToggle.addEventListener('click', () => {
            const isCollapsed = sidebar.classList.toggle('collapsed');
            sidebarToggle.innerHTML = isCollapsed ? '‹' : '›';
            saveSidebarState(isCollapsed);
            // Remove body class management since sidebar now overlays
        });

        // Close sidebar when clicking outside of it
        document.addEventListener('click', (e) => {
            // Don't close if clicking on the sidebar itself or the toggle button
            if (!sidebar.contains(e.target) && e.target !== sidebarToggle) {
                // Only close if sidebar is currently open
                if (!sidebar.classList.contains('collapsed')) {
                    sidebar.classList.add('collapsed');
                    sidebarToggle.innerHTML = '‹';
                    saveSidebarState(true); // Save the collapsed state
                    // Remove body class management since sidebar now overlays
                }
            }
        });
        
        // Fullscreen toggle function
        function toggleFullscreen() {
            const videoContainer = document.querySelector('.video-container');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            
            if (videoContainer.classList.contains('fullscreen')) {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                videoContainer.classList.remove('fullscreen');
                fullscreenBtn.querySelector('.material-icons').textContent = 'fullscreen';
            } else {
                // Enter fullscreen
                if (videoContainer.requestFullscreen) {
                    videoContainer.requestFullscreen();
                } else if (videoContainer.webkitRequestFullscreen) {
                    videoContainer.webkitRequestFullscreen();
                } else if (videoContainer.mozRequestFullScreen) {
                    videoContainer.mozRequestFullScreen();
                } else if (videoContainer.msRequestFullscreen) {
                    videoContainer.msRequestFullscreen();
                }
                videoContainer.classList.add('fullscreen');
                fullscreenBtn.querySelector('.material-icons').textContent = 'fullscreen_exit';
            }
        }
        
        // Listen for fullscreen change events from browser API
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        function handleFullscreenChange() {
            const videoContainer = document.querySelector('.video-container');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            
            if (document.fullscreenElement || 
                document.webkitFullscreenElement || 
                document.mozFullScreenElement || 
                document.msFullscreenElement) {
                // We're in fullscreen mode
                videoContainer.classList.add('fullscreen');
                fullscreenBtn.querySelector('.material-icons').textContent = 'fullscreen_exit';
            } else {
                // We're not in fullscreen mode
                videoContainer.classList.remove('fullscreen');
                fullscreenBtn.querySelector('.material-icons').textContent = 'fullscreen';
            }
        }
        
        // Screenshot function
        function takeScreenshot() {
            const video = document.getElementById('video-stream');
            
            // Create a canvas element to draw the image
            const canvas = document.createElement('canvas');
            canvas.width = video.naturalWidth;
            canvas.height = video.naturalHeight;
            
            // Draw the current video frame to the canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            try {
                // Convert canvas to a data URL and create a download link
                const dataURL = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = dataURL;
                
                // Generate timestamp for the filename
                const date = new Date();
                const timestamp = date.toISOString()
                    .replace(/:/g, '-')
                    .replace(/\..+/, '')
                    .replace('T', '_');
                
                a.download = `kvm_screenshot_${timestamp}.png`;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(dataURL);
                }, 100);
                
                // Show a brief notification
                const notification = document.createElement('div');
                notification.style.position = 'fixed';
                notification.style.bottom = '20px';
                notification.style.left = '50%';
                notification.style.transform = 'translateX(-50%)';
                notification.style.background = 'rgba(0, 0, 0, 0.8)';
                notification.style.color = 'white';
                notification.style.padding = '10px 20px';
                notification.style.borderRadius = '4px';
                notification.style.zIndex = '9999';
                notification.innerHTML = '<span class="material-icons" style="vertical-align: middle; margin-right: 8px;">check_circle</span> Screenshot saved';
                
                document.body.appendChild(notification);
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => document.body.removeChild(notification), 500);
                }, 2000);
                
            } catch (error) {
                console.error('Error taking screenshot:', error);
                alert('Failed to take screenshot. This may be due to security restrictions.');
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadSidebarState(); // Load sidebar state first
            initializeVideo();
            updateStatus();
            measureLatency();
            refreshUsbImages();
            setInterval(updateStatus, 5000);
            setInterval(measureLatency, 3000);
            setupVideoCapture();
            
            // Show controls hint briefly
            setTimeout(() => {
                const controlsHint = document.getElementById('controls-hint');
                if (controlsHint) {
                    controlsHint.style.display = 'inline-block';
                    setTimeout(() => {
                        controlsHint.style.opacity = '0';
                        controlsHint.style.transition = 'opacity 1s ease';
                        setTimeout(() => {
                            controlsHint.style.display = 'none';
                            controlsHint.style.opacity = '1';
                        }, 1000);
                    }, 5000);
                }
            }, 2000);
        });
    </script>
</body>
</html>
